"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = processPattern;

var _path = _interopRequireDefault(require("path"));

var _globby = _interopRequireDefault(require("globby"));

var _createPatternGlob = _interopRequireDefault(require("./utils/createPatternGlob"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function processPattern(globalRef, pattern) {
  const {
    logger,
    output,
    compilation
  } = globalRef;
  (0, _createPatternGlob.default)(pattern, globalRef);
  logger.log(`begin globbing '${pattern.glob}' with a context of '${pattern.context}'`);
  const paths = await (0, _globby.default)(pattern.glob, pattern.globOptions);

  if (paths.length === 0) {
    if (pattern.noErrorOnMissing) {
      return Promise.resolve();
    }

    const missingError = new Error(`unable to locate '${pattern.from}' at '${pattern.absoluteFrom}'`);
    logger.error(missingError.message);
    compilation.errors.push(missingError);
    return Promise.resolve();
  }

  return paths.map(filepath => {
    let from;

    if (typeof filepath === 'string') {
      from = filepath;
    } else {
      from = filepath.path;
    }

    const file = {
      absoluteFrom: _path.default.resolve(pattern.context, from)
    };
    file.relativeFrom = _path.default.relative(pattern.context, file.absoluteFrom);

    if (pattern.flatten) {
      file.relativeFrom = _path.default.basename(file.relativeFrom);
    }

    logger.debug(`found ${from}`); // Change the to path to be relative for webpack

    file.webpackTo = pattern.toType === 'dir' ? _path.default.join(pattern.to, file.relativeFrom) : pattern.to;

    if (_path.default.isAbsolute(file.webpackTo)) {
      file.webpackTo = _path.default.relative(output, file.webpackTo);
    }

    logger.log(`determined that '${from}' should write to '${file.webpackTo}'`);
    return file;
  });
}